diff -ru /tmp/v1/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java /tmp/v2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
--- /tmp/v1/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java	2021-09-30 13:57:43.528622207 +0200
+++ /tmp/v2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java	2021-09-30 13:36:17.135468541 +0200
@@ -17,12 +17,15 @@
 package com.google.gson.internal.bind;
 
 import java.io.IOException;
+import java.lang.reflect.Field;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.InetAddress;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.sql.Timestamp;
 import java.util.ArrayList;
 import java.util.BitSet;
@@ -776,9 +779,20 @@
 
     public EnumTypeAdapter(Class<T> classOfT) {
       try {
-        for (T constant : classOfT.getEnumConstants()) {
+        for (final Field field : classOfT.getDeclaredFields()) {
+          if (!field.isEnumConstant()) {
+            continue;
+          }
+          AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            @Override public Void run() {
+              field.setAccessible(true);
+              return null;
+            }
+          });
+          @SuppressWarnings("unchecked")
+          T constant = (T)(field.get(null));
           String name = constant.name();
-          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);
+          SerializedName annotation = field.getAnnotation(SerializedName.class);
           if (annotation != null) {
             name = annotation.value();
             for (String alternate : annotation.alternate()) {
@@ -788,7 +802,7 @@
           nameToConstant.put(name, constant);
           constantToName.put(constant, name);
         }
-      } catch (NoSuchFieldException e) {
+      } catch (IllegalAccessException e) {
         throw new AssertionError(e);
       }
     }
diff -ru /tmp/v1/gson/src/main/java/com/google/gson/internal/$Gson$Types.java /tmp/v2/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
--- /tmp/v1/gson/src/main/java/com/google/gson/internal/$Gson$Types.java	2021-09-30 13:57:43.528622207 +0200
+++ /tmp/v2/gson/src/main/java/com/google/gson/internal/$Gson$Types.java	2021-09-30 13:36:17.135468541 +0200
@@ -25,7 +25,12 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.util.*;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Properties;
 
 import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
 import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
@@ -334,52 +339,61 @@
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());
+    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable<?>, Type>());
   }
 
   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
-                              Collection<TypeVariable> visitedTypeVariables) {
+                              Map<TypeVariable<?>, Type> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
+    TypeVariable<?> resolving = null;
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        if (visitedTypeVariables.contains(typeVariable)) {
+        Type previouslyResolved = visitedTypeVariables.get(typeVariable);
+        if (previouslyResolved != null) {
           // cannot reduce due to infinite recursion
-          return toResolve;
-        } else {
-          visitedTypeVariables.add(typeVariable);
+          return (previouslyResolved == Void.TYPE) ? toResolve : previouslyResolved;
         }
+
+        // Insert a placeholder to mark the fact that we are in the process of resolving this type
+        visitedTypeVariables.put(typeVariable, Void.TYPE);
+        if (resolving == null) {
+          resolving = typeVariable;
+        }
+
         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
         if (toResolve == typeVariable) {
-          return toResolve;
+          break;
         }
 
       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
         Class<?> original = (Class<?>) toResolve;
         Type componentType = original.getComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        return componentType == newComponentType
+        toResolve = equal(componentType, newComponentType)
             ? original
             : arrayOf(newComponentType);
+        break;
 
       } else if (toResolve instanceof GenericArrayType) {
         GenericArrayType original = (GenericArrayType) toResolve;
         Type componentType = original.getGenericComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        return componentType == newComponentType
+        toResolve = equal(componentType, newComponentType)
             ? original
             : arrayOf(newComponentType);
+        break;
 
       } else if (toResolve instanceof ParameterizedType) {
         ParameterizedType original = (ParameterizedType) toResolve;
         Type ownerType = original.getOwnerType();
         Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
-        boolean changed = newOwnerType != ownerType;
+        boolean changed = !equal(newOwnerType, ownerType);
 
         Type[] args = original.getActualTypeArguments();
         for (int t = 0, length = args.length; t < length; t++) {
           Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
-          if (resolvedTypeArgument != args[t]) {
+          if (!equal(resolvedTypeArgument, args[t])) {
             if (!changed) {
               args = args.clone();
               changed = true;
@@ -388,9 +402,10 @@
           }
         }
 
-        return changed
+        toResolve = changed
             ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)
             : original;
+        break;
 
       } else if (toResolve instanceof WildcardType) {
         WildcardType original = (WildcardType) toResolve;
@@ -400,20 +415,28 @@
         if (originalLowerBound.length == 1) {
           Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
           if (lowerBound != originalLowerBound[0]) {
-            return supertypeOf(lowerBound);
+            toResolve = supertypeOf(lowerBound);
+            break;
           }
         } else if (originalUpperBound.length == 1) {
           Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
           if (upperBound != originalUpperBound[0]) {
-            return subtypeOf(upperBound);
+            toResolve = subtypeOf(upperBound);
+            break;
           }
         }
-        return original;
+        toResolve = original;
+        break;
 
       } else {
-        return toResolve;
+        break;
       }
     }
+    // ensure that any in-process resolution gets updated with the final result
+    if (resolving != null) {
+      visitedTypeVariables.put(resolving, toResolve);
+    }
+    return toResolve;
   }
 
   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
diff -ru /tmp/v1/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java /tmp/v2/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
--- /tmp/v1/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java	2021-09-30 13:57:43.528622207 +0200
+++ /tmp/v2/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java	2021-09-30 11:43:34.418619203 +0200
@@ -79,7 +79,7 @@
   private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField("override");
-    } catch (NoSuchFieldException e) {
+    } catch (Exception e) {
       return null;
     }
   }
Only in /tmp/v2/gson/src/test/java/com/google/gson/functional: EnumWithObfuscatedTest.java
Only in /tmp/v2/gson/src/test/java/com/google/gson/functional: ReusedTypeVariablesFullyResolveTest.java
diff -ru /tmp/v1/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java /tmp/v2/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
--- /tmp/v1/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java	2021-09-30 13:57:43.528622207 +0200
+++ /tmp/v2/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java	2021-09-30 11:43:34.426619137 +0200
@@ -15,10 +15,12 @@
  */
 package com.google.gson.internal.reflect;
 
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.lang.reflect.Field;
+import java.security.Permission;
 
 import org.junit.Test;
 
@@ -41,6 +43,30 @@
     }
   }
 
+  @Test
+  public void testMakeAccessibleWithRestrictiveSecurityManager() throws Exception {
+    final Permission accessDeclaredMembers = new RuntimePermission("accessDeclaredMembers");
+    final SecurityManager original = System.getSecurityManager();
+    SecurityManager restrictiveManager = new SecurityManager() {
+      @Override
+      public void checkPermission(Permission perm) {
+        if (accessDeclaredMembers.equals(perm)) {
+          throw new SecurityException("nope");
+        }
+      }
+    };
+    System.setSecurityManager(restrictiveManager);
+
+    try {
+      UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
+      Field field = ClassWithPrivateFinalFields.class.getDeclaredField("a");
+      assertFalse("override field should have been inaccessible", accessor.makeAccessibleWithUnsafe(field));
+      accessor.makeAccessible(field);
+    } finally {
+      System.setSecurityManager(original);
+    }
+  }
+
   @SuppressWarnings("unused")
   private static final class ClassWithPrivateFinalFields {
     private final String a;
Only in /tmp/v2/gson/src/test: resources
