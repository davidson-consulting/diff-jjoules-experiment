diff -ru /tmp/v1/gson/src/main/java/com/google/gson/internal/$Gson$Types.java /tmp/v2/gson/src/main/java/com/google/gson/internal/$Gson$Types.java
--- /tmp/v1/gson/src/main/java/com/google/gson/internal/$Gson$Types.java	2021-09-30 22:34:29.424891458 +0200
+++ /tmp/v2/gson/src/main/java/com/google/gson/internal/$Gson$Types.java	2021-09-30 18:01:31.717634097 +0200
@@ -25,12 +25,7 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Properties;
+import java.util.*;
 
 import static com.google.gson.internal.$Gson$Preconditions.checkArgument;
 import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;
@@ -339,61 +334,52 @@
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable, Type>());
+    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());
   }
 
   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
-                              Map<TypeVariable, Type> visitedTypeVariables) {
+                              Collection<TypeVariable> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
-    TypeVariable resolving = null;
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;
-        Type previouslyResolved = visitedTypeVariables.get(typeVariable);
-        if (previouslyResolved != null) {
+        if (visitedTypeVariables.contains(typeVariable)) {
           // cannot reduce due to infinite recursion
-          return (previouslyResolved == Void.TYPE) ? toResolve : previouslyResolved;
+          return toResolve;
+        } else {
+          visitedTypeVariables.add(typeVariable);
         }
-
-        // Insert a placeholder to mark the fact that we are in the process of resolving this type
-        visitedTypeVariables.put(typeVariable, Void.TYPE);
-        if (resolving == null) {
-          resolving = typeVariable;
-        }
-
         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);
         if (toResolve == typeVariable) {
-          break;
+          return toResolve;
         }
 
       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {
         Class<?> original = (Class<?>) toResolve;
         Type componentType = original.getComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        toResolve = equal(componentType, newComponentType)
+        return componentType == newComponentType
             ? original
             : arrayOf(newComponentType);
-        break;
 
       } else if (toResolve instanceof GenericArrayType) {
         GenericArrayType original = (GenericArrayType) toResolve;
         Type componentType = original.getGenericComponentType();
         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);
-        toResolve = equal(componentType, newComponentType)
+        return componentType == newComponentType
             ? original
             : arrayOf(newComponentType);
-        break;
 
       } else if (toResolve instanceof ParameterizedType) {
         ParameterizedType original = (ParameterizedType) toResolve;
         Type ownerType = original.getOwnerType();
         Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);
-        boolean changed = !equal(newOwnerType, ownerType);
+        boolean changed = newOwnerType != ownerType;
 
         Type[] args = original.getActualTypeArguments();
         for (int t = 0, length = args.length; t < length; t++) {
           Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);
-          if (!equal(resolvedTypeArgument, args[t])) {
+          if (resolvedTypeArgument != args[t]) {
             if (!changed) {
               args = args.clone();
               changed = true;
@@ -402,10 +388,9 @@
           }
         }
 
-        toResolve = changed
+        return changed
             ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)
             : original;
-        break;
 
       } else if (toResolve instanceof WildcardType) {
         WildcardType original = (WildcardType) toResolve;
@@ -415,28 +400,20 @@
         if (originalLowerBound.length == 1) {
           Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);
           if (lowerBound != originalLowerBound[0]) {
-            toResolve = supertypeOf(lowerBound);
-            break;
+            return supertypeOf(lowerBound);
           }
         } else if (originalUpperBound.length == 1) {
           Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);
           if (upperBound != originalUpperBound[0]) {
-            toResolve = subtypeOf(upperBound);
-            break;
+            return subtypeOf(upperBound);
           }
         }
-        toResolve = original;
-        break;
+        return original;
 
       } else {
-        break;
+        return toResolve;
       }
     }
-    // ensure that any in-process resolution gets updated with the final result
-    if (resolving != null) {
-      visitedTypeVariables.put(resolving, toResolve);
-    }
-    return toResolve;
   }
 
   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {
Only in /tmp/v1/gson/src/test/java/com/google/gson/functional: ReusedTypeVariablesFullyResolveTest.java
