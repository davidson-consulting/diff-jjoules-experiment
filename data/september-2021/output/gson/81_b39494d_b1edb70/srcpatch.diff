diff -ru /tmp/v1/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java /tmp/v2/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
--- /tmp/v1/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java	2021-09-22 15:52:19.260465588 +0200
+++ /tmp/v2/gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java	2021-09-22 15:02:05.171884062 +0200
@@ -79,7 +79,7 @@
   private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField("override");
-    } catch (Exception e) {
+    } catch (NoSuchFieldException e) {
       return null;
     }
   }
diff -ru /tmp/v1/gson/src/main/java/com/google/gson/JsonStreamParser.java /tmp/v2/gson/src/main/java/com/google/gson/JsonStreamParser.java
--- /tmp/v1/gson/src/main/java/com/google/gson/JsonStreamParser.java	2021-09-22 15:52:19.260465588 +0200
+++ /tmp/v2/gson/src/main/java/com/google/gson/JsonStreamParser.java	2021-09-22 15:52:19.264465665 +0200
@@ -29,8 +29,9 @@
 
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
- * asynchronously.
- * 
+ * asynchronously. The JSON data is parsed in lenient mode, see also
+ * {@link JsonReader#setLenient(boolean)}.
+ *
  * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To
  * properly use this class across multiple threads, you will need to add some external
  * synchronization. For example:
@@ -72,10 +73,12 @@
   }
   
   /**
-   * Returns the next available {@link JsonElement} on the reader. Null if none available.
-   * 
-   * @return the next available {@link JsonElement} on the reader. Null if none available.
-   * @throws JsonParseException if the incoming stream is malformed JSON.
+   * Returns the next available {@link JsonElement} on the reader. Throws a
+   * {@link NoSuchElementException} if no element is available.
+   *
+   * @return the next available {@code JsonElement} on the reader.
+   * @throws JsonSyntaxException if the incoming stream is malformed JSON.
+   * @throws NoSuchElementException if no {@code JsonElement} is available.
    * @since 1.4
    */
   public JsonElement next() throws JsonParseException {
@@ -97,6 +100,7 @@
   /**
    * Returns true if a {@link JsonElement} is available on the input for consumption
    * @return true if a {@link JsonElement} is available on the input, false otherwise
+   * @throws JsonSyntaxException if the incoming stream is malformed JSON.
    * @since 1.4
    */
   public boolean hasNext() {
diff -ru /tmp/v1/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java /tmp/v2/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java
--- /tmp/v1/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java	2021-09-22 15:52:19.260465588 +0200
+++ /tmp/v2/gson/src/test/java/com/google/gson/internal/reflect/UnsafeReflectionAccessorTest.java	2021-09-22 15:02:05.171884062 +0200
@@ -15,12 +15,10 @@
  */
 package com.google.gson.internal.reflect;
 
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.lang.reflect.Field;
-import java.security.Permission;
 
 import org.junit.Test;
 
@@ -43,30 +41,6 @@
     }
   }
 
-  @Test
-  public void testMakeAccessibleWithRestrictiveSecurityManager() throws Exception {
-    final Permission accessDeclaredMembers = new RuntimePermission("accessDeclaredMembers");
-    final SecurityManager original = System.getSecurityManager();
-    SecurityManager restrictiveManager = new SecurityManager() {
-      @Override
-      public void checkPermission(Permission perm) {
-        if (accessDeclaredMembers.equals(perm)) {
-          throw new SecurityException("nope");
-        }
-      }
-    };
-    System.setSecurityManager(restrictiveManager);
-
-    try {
-      UnsafeReflectionAccessor accessor = new UnsafeReflectionAccessor();
-      Field field = ClassWithPrivateFinalFields.class.getDeclaredField("a");
-      assertFalse("override field should have been inaccessible", accessor.makeAccessibleWithUnsafe(field));
-      accessor.makeAccessible(field);
-    } finally {
-      System.setSecurityManager(original);
-    }
-  }
-
   @SuppressWarnings("unused")
   private static final class ClassWithPrivateFinalFields {
     private final String a;
