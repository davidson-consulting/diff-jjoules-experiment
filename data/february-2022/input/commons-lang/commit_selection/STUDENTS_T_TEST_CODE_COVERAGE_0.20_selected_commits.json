{
    "372": {
        "size": 157,
        "decision": "pass",
        "diff": "diff -ru src/main/java/org/apache/commons/lang3/CharSequenceUtils.java src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n--- src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\t2022-06-06 18:05:14.247934406 +0200\n+++ src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\t2022-06-06 18:05:14.271934542 +0200\n@@ -27,33 +27,46 @@\n \n     private static final int NOT_FOUND = -1;\n \n-    /**\n-     * <p>{@code CharSequenceUtils} instances should NOT be constructed in\n-     * standard programming. </p>\n-     *\n-     * <p>This constructor is public to permit tools that require a JavaBean\n-     * instance to operate.</p>\n-     */\n-    public CharSequenceUtils() {\n+    static final int TO_STRING_LIMIT = 16;\n+\n+    private static boolean checkLaterThan1(final CharSequence cs, final CharSequence searchChar, final int len2, final int start1) {\n+        for (int i = 1, j = len2 - 1; i <= j; i++, j--) {\n+            if (cs.charAt(start1 + i) != searchChar.charAt(i)\n+                    ||\n+                    cs.charAt(start1 + j) != searchChar.charAt(j)\n+            ) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Returns a new {@code CharSequence} that is a subsequence of this\n-     * sequence starting with the {@code char} value at the specified index.</p>\n-     *\n-     * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n-     * The length (in {@code char}) of the returned sequence is {@code length() - start},\n-     * so if {@code start == end} then an empty sequence is returned.</p>\n+     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n      *\n-     * @param cs  the specified subsequence, null returns null\n-     * @param start  the start index, inclusive, valid\n-     * @return a new subsequence, may be null\n-     * @throws IndexOutOfBoundsException if {@code start} is negative or if\n-     *  {@code start} is greater than {@code length()}\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n      */\n-    public static CharSequence subSequence(final CharSequence cs, final int start) {\n-        return cs == null ? null : cs.subSequence(start, cs.length());\n+    static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).indexOf(searchChar.toString(), start);\n+        } else if (cs instanceof StringBuilder) {\n+            return ((StringBuilder) cs).indexOf(searchChar.toString(), start);\n+        } else if (cs instanceof StringBuffer) {\n+            return ((StringBuffer) cs).indexOf(searchChar.toString(), start);\n+        }\n+        return cs.toString().indexOf(searchChar.toString(), start);\n+//        if (cs instanceof String && searchChar instanceof String) {\n+//            // TODO: Do we assume searchChar is usually relatively small;\n+//            //       If so then calling toString() on it is better than reverting to\n+//            //       the green implementation in the else block\n+//            return ((String) cs).indexOf((String) searchChar, start);\n+//        } else {\n+//            // TODO: Implement rather than convert to String\n+//            return cs.toString().indexOf(searchChar.toString(), start);\n+//        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -126,100 +139,6 @@\n     }\n \n     /**\n-     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the {@code CharSequence} to be searched for\n-     * @param start the start index\n-     * @return the index where the search sequence was found\n-     */\n-    static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {\n-        if (cs instanceof String) {\n-            return ((String) cs).indexOf(searchChar.toString(), start);\n-        } else if (cs instanceof StringBuilder) {\n-            return ((StringBuilder) cs).indexOf(searchChar.toString(), start);\n-        } else if (cs instanceof StringBuffer) {\n-            return ((StringBuffer) cs).indexOf(searchChar.toString(), start);\n-        }\n-        return cs.toString().indexOf(searchChar.toString(), start);\n-//        if (cs instanceof String && searchChar instanceof String) {\n-//            // TODO: Do we assume searchChar is usually relatively small;\n-//            //       If so then calling toString() on it is better than reverting to\n-//            //       the green implementation in the else block\n-//            return ((String) cs).indexOf((String) searchChar, start);\n-//        } else {\n-//            // TODO: Implement rather than convert to String\n-//            return cs.toString().indexOf(searchChar.toString(), start);\n-//        }\n-    }\n-\n-    /**\n-     * Returns the index within {@code cs} of the last occurrence of\n-     * the specified character, searching backward starting at the\n-     * specified index. For values of {@code searchChar} in the range\n-     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n-     * value <i>k</i> such that:\n-     * <blockquote><pre>\n-     * (this.charAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= start)\n-     * </pre></blockquote>\n-     * is true. For other values of {@code searchChar}, it is the\n-     * largest value <i>k</i> such that:\n-     * <blockquote><pre>\n-     * (this.codePointAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= start)\n-     * </pre></blockquote>\n-     * is true. In either case, if no such character occurs in {@code cs}\n-     * at or before position {@code start}, then {@code -1} is returned.\n-     *\n-     * <p>All indices are specified in {@code char} values\n-     * (Unicode code units).\n-     *\n-     * @param cs  the {@code CharSequence} to be processed\n-     * @param searchChar  the char to be searched for\n-     * @param start  the start index, negative returns -1, beyond length starts at end\n-     * @return the index where the search char was found, -1 if not found\n-     * @since 3.6 updated to behave more like {@code String}\n-     */\n-    static int lastIndexOf(final CharSequence cs, final int searchChar, int start) {\n-        if (cs instanceof String) {\n-            return ((String) cs).lastIndexOf(searchChar, start);\n-        }\n-        final int sz = cs.length();\n-        if (start < 0) {\n-            return NOT_FOUND;\n-        }\n-        if (start >= sz) {\n-            start = sz - 1;\n-        }\n-        if (searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n-            for (int i = start; i >= 0; --i) {\n-                if (cs.charAt(i) == searchChar) {\n-                    return i;\n-                }\n-            }\n-            return NOT_FOUND;\n-        }\n-        //supplementary characters (LANG1300)\n-        //NOTE - we must do a forward traversal for this to avoid duplicating code points\n-        if (searchChar <= Character.MAX_CODE_POINT) {\n-            final char[] chars = Character.toChars(searchChar);\n-            //make sure it's not the last index\n-            if (start == sz - 1) {\n-                return NOT_FOUND;\n-            }\n-            for (int i = start; i >= 0; i--) {\n-                final char high = cs.charAt(i);\n-                final char low = cs.charAt(i + 1);\n-                if (chars[0] == high && chars[1] == low) {\n-                    return i;\n-                }\n-            }\n-        }\n-        return NOT_FOUND;\n-    }\n-\n-    static final int TO_STRING_LIMIT = 16;\n-\n-    /**\n      * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n      *\n      * @param cs the {@code CharSequence} to be processed\n@@ -290,38 +209,68 @@\n         }\n     }\n \n-    private static boolean checkLaterThan1(final CharSequence cs, final CharSequence searchChar, final int len2, final int start1) {\n-        for (int i = 1, j = len2 - 1; i <= j; i++, j--) {\n-            if (cs.charAt(start1 + i) != searchChar.charAt(i)\n-                    ||\n-                    cs.charAt(start1 + j) != searchChar.charAt(j)\n-            ) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n     /**\n-     * Converts the given CharSequence to a char[].\n+     * Returns the index within {@code cs} of the last occurrence of\n+     * the specified character, searching backward starting at the\n+     * specified index. For values of {@code searchChar} in the range\n+     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n+     * value <i>k</i> such that:\n+     * <blockquote><pre>\n+     * (this.charAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= start)\n+     * </pre></blockquote>\n+     * is true. For other values of {@code searchChar}, it is the\n+     * largest value <i>k</i> such that:\n+     * <blockquote><pre>\n+     * (this.codePointAt(<i>k</i>) == searchChar) &amp;&amp; (<i>k</i> &lt;= start)\n+     * </pre></blockquote>\n+     * is true. In either case, if no such character occurs in {@code cs}\n+     * at or before position {@code start}, then {@code -1} is returned.\n      *\n-     * @param source the {@code CharSequence} to be processed.\n-     * @return the resulting char array, never null.\n-     * @since 3.11\n+     * <p>All indices are specified in {@code char} values\n+     * (Unicode code units).\n+     *\n+     * @param cs  the {@code CharSequence} to be processed\n+     * @param searchChar  the char to be searched for\n+     * @param start  the start index, negative returns -1, beyond length starts at end\n+     * @return the index where the search char was found, -1 if not found\n+     * @since 3.6 updated to behave more like {@code String}\n      */\n-    public static char[] toCharArray(final CharSequence source) {\n-        final int len = StringUtils.length(source);\n-        if (len == 0) {\n-            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+    static int lastIndexOf(final CharSequence cs, final int searchChar, int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).lastIndexOf(searchChar, start);\n         }\n-        if (source instanceof String) {\n-            return ((String) source).toCharArray();\n+        final int sz = cs.length();\n+        if (start < 0) {\n+            return NOT_FOUND;\n         }\n-        final char[] array = new char[len];\n-        for (int i = 0; i < len; i++) {\n-            array[i] = source.charAt(i);\n+        if (start >= sz) {\n+            start = sz - 1;\n         }\n-        return array;\n+        if (searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+            for (int i = start; i >= 0; --i) {\n+                if (cs.charAt(i) == searchChar) {\n+                    return i;\n+                }\n+            }\n+            return NOT_FOUND;\n+        }\n+        //supplementary characters (LANG1300)\n+        //NOTE - we must do a forward traversal for this to avoid duplicating code points\n+        if (searchChar <= Character.MAX_CODE_POINT) {\n+            final char[] chars = Character.toChars(searchChar);\n+            //make sure it's not the last index\n+            if (start == sz - 1) {\n+                return NOT_FOUND;\n+            }\n+            for (int i = start; i >= 0; i--) {\n+                final char high = cs.charAt(i);\n+                final char low = cs.charAt(i + 1);\n+                if (chars[0] == high && chars[1] == low) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return NOT_FOUND;\n     }\n \n     /**\n@@ -380,4 +329,55 @@\n \n         return true;\n     }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a new {@code CharSequence} that is a subsequence of this\n+     * sequence starting with the {@code char} value at the specified index.</p>\n+     *\n+     * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n+     * The length (in {@code char}) of the returned sequence is {@code length() - start},\n+     * so if {@code start == end} then an empty sequence is returned.</p>\n+     *\n+     * @param cs  the specified subsequence, null returns null\n+     * @param start  the start index, inclusive, valid\n+     * @return a new subsequence, may be null\n+     * @throws IndexOutOfBoundsException if {@code start} is negative or if\n+     *  {@code start} is greater than {@code length()}\n+     */\n+    public static CharSequence subSequence(final CharSequence cs, final int start) {\n+        return cs == null ? null : cs.subSequence(start, cs.length());\n+    }\n+\n+    /**\n+     * Converts the given CharSequence to a char[].\n+     *\n+     * @param source the {@code CharSequence} to be processed.\n+     * @return the resulting char array, never null.\n+     * @since 3.11\n+     */\n+    public static char[] toCharArray(final CharSequence source) {\n+        final int len = StringUtils.length(source);\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        if (source instanceof String) {\n+            return ((String) source).toCharArray();\n+        }\n+        final char[] array = new char[len];\n+        for (int i = 0; i < len; i++) {\n+            array[i] = source.charAt(i);\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>{@code CharSequenceUtils} instances should NOT be constructed in\n+     * standard programming. </p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public CharSequenceUtils() {\n+    }\n }\n",
        "sha1": "6087c1d",
        "sha2": "c11e895"
    },
    "104": {
        "size": 2,
        "decision": "break",
        "diff": "diff -ru src/main/java/org/apache/commons/lang3/tuple/Triple.java src/main/java/org/apache/commons/lang3/tuple/Triple.java\n--- src/main/java/org/apache/commons/lang3/tuple/Triple.java\t2022-06-06 18:05:11.671919793 +0200\n+++ src/main/java/org/apache/commons/lang3/tuple/Triple.java\t2022-06-06 18:05:11.611919452 +0200\n@@ -103,7 +103,7 @@\n      * @return a triple formed from the three parameters, not null\n      */\n     public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {\n-        return new ImmutableTriple<>(left, middle, right);\n+        return ImmutableTriple.of(left, middle, right);\n     }\n \n     /**\n",
        "sha1": "ae2ba9d",
        "sha2": "3ffa669",
        "config": "STUDENTS_T_TEST_CODE_COVERAGE_0.20"
    }
}